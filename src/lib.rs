//! # graphviz
//!
//! This crate provides an idiomatic Rust wrapper over the Graphviz C libraries (`libgvc` and `libcgraph`),
//! enabling you to create, layout, and render graphs using Graphviz in a safe and ergonomic way.
//!
//! ## Features
//! - Construct graphs from DOT source or programmatically
//! - Add nodes and edges with fine-grained attribute control
//! - Apply Graphviz attributes using strongly typed enums
//! - Support for Graphviz layout engines (`dot`, `neato`, `fdp`, etc.)
//! - Output to formats like `svg`, `png`, `dot`, `json`, and many more
//! - Extensible trait-based attribute system
//! - Optional `serde` support for attribute enums
//!
//! ## Example
//! This example will only work if bindgen is enabled (which is default)
//! ```rust
//! use wrappedviz::*;
//! use wrappedviz::cgraph::{Context, Graph};
//! use wrappedviz::style::{NodeAttr, GraphAttr, CommonAttr};
//! use wrappedviz::style::shape::NodeShape;
//!
//! fn main() {
//!     let ctx = Context::new();
//!
//!     // Start with an empty directed graph
//!     let mut graph = Graph::new("digraph G {}", &ctx);
//!
//!     // Add nodes A and B
//!     graph.add_node("A");
//!     graph.add_node("B");
//!
//!     graph.add_edge("A", "B", "A_to_B");
//!
//!     // Style node A
//!     graph.set_attr_on_node("A", NodeAttr::Shape(NodeShape::Box)).unwrap();
//!
//!     // Label the edge
//!     graph.set_attr_on_edge("A_to_B", CommonAttr::Label("A to B".into())).unwrap();
//!
//!     // Set graph-level attributes
//!     graph.set_attr_on_graph(GraphAttr::RankDir(style::RankDir::LR)).unwrap();
//!
//!     // Layout the graph using `dot`
//!     graph.set_layout(Layout::Dot);
//!
//!     // Render the graph to SVG format
//!     let svg = ctx.render(&graph, OutputFormat::Svg).unwrap();
//!     std::fs::write("example.svg", svg).unwrap();
//! }
//! ```
//! 
//! # SVG generated by above code:
//! 
//! <?xml version="1.0" encoding="UTF-8" standalone="no"?>
//! <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
//! "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
//! <!-- Generated by graphviz version 13.0.0 (0) -->
//! <!-- Title: G Pages: 1 -->
//! <svg width="196pt" height="44pt" viewBox="0.00 0.00 196.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
//! <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
//! <title>G</title>
//! <polygon fill="white" stroke="none" points="-4,4 -4,-40 191.5,-40 191.5,4 -4,4"/>
//! <!-- A -->
//! <g id="node1" class="node">
//! <title>A</title>
//! <polygon fill="none" stroke="black" points="54,-36 0,-36 0,0 54,0 54,-36"/>
//! <text xml:space="preserve" text-anchor="middle" x="27" y="-13.32" font-family="Times,serif" font-size="14.00">A</text>
//! </g>
//! <!-- B -->
//! <g id="node2" class="node">
//! <title>B</title>
//! <ellipse fill="none" stroke="black" cx="160.5" cy="-18" rx="27" ry="18"/>
//! <text xml:space="preserve" text-anchor="middle" x="160.5" y="-13.32" font-family="Times,serif" font-size="14.00">B</text>
//! </g>
//! <!-- A&#45;&gt;B -->
//! <g id="edge1" class="edge">
//! <title>A&#45;&gt;B</title>
//! <path fill="none" stroke="black" d="M54.29,-18C73.65,-18 100.23,-18 121.84,-18"/>
//! <polygon fill="black" stroke="black" points="121.74,-21.5 131.74,-18 121.74,-14.5 121.74,-21.5"/>
//! <text xml:space="preserve" text-anchor="middle" x="93.75" y="-21.95" font-family="Times,serif" font-size="14.00">A to B</text>
//! </g>
//! </g>
//! </svg>
//! 
//! ## Safety
//! While this crate provides a safe wrapper over unsafe C bindings, all `Graph` objects must be dropped before their parent `Context`.
//!
//! ## Optional Features
//! - `serde`: Enables serialization and deserialization for enums like `Layout`, `OutputFormat`, and attribute types.
//!
//! ## License
//! Licensed under MIT or Apache-2.0.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(improper_ctypes)]
#![allow(unsafe_code)]
#![allow(clippy::useless_transmute, clippy::transmute_ptr_to_ptr, clippy::transmute_ptr_to_ref)]
use crate::style::NodeAttribute;
use crate::style::EdgeAttribute;
use crate::style::GraphAttr;
use crate::style::ClusterAttribute;
use std::error::Error;
use crate::style::Attribute;
use crate::style::{EdgeAttr, NodeAttr};
use std::collections::HashMap;
use std::ffi::CString;
use std::fmt;
use std::ptr;
use std::str::FromStr;
use std::ffi::CStr;
pub use style::shape::NodeShape;
/// provides style attributes that can be passed to graphviz
pub mod style;
/// provides serde compatible structures for easily defining graph themes.
pub mod theme;
/// raw FFI bindings generated by bindgen using libclang
#[cfg(all(feature = "bindings", not(target_arch = "wasm32")))]
pub mod sys;

/// A pure rust representation of data needed to construct graphviz graph
/// this module is useful for the use of serde serialization.
pub mod rgraph;
/// provides types that wrap graphviz
#[cfg(all(feature = "bindings", not(target_arch = "wasm32")))]
pub mod cgraph;

use crate::style::{CommonAttr};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(
    feature = "serde",
    derive(serde_derive::Serialize, serde_derive::Deserialize)
)]
pub enum Layout {
    Circo,
    Dot,
    Fdp,
    Neato,
    Nop,
    Nop1,
    Nop2,
    Osage,
    Patchwork,
    Sfdp,
    Twopi,
}

impl fmt::Display for Layout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            Layout::Circo => "circo",
            Layout::Dot => "dot",
            Layout::Fdp => "fdp",
            Layout::Neato => "neato",
            Layout::Nop => "nop",
            Layout::Nop1 => "nop1",
            Layout::Nop2 => "nop2",
            Layout::Osage => "osage",
            Layout::Patchwork => "patchwork",
            Layout::Sfdp => "sfdp",
            Layout::Twopi => "twopi",
        };
        write!(f, "{}", s)
    }
}

impl FromStr for Layout {
    type Err = String;

    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input.to_ascii_lowercase().as_str() {
            "circo" => Ok(Layout::Circo),
            "dot" => Ok(Layout::Dot),
            "fdp" => Ok(Layout::Fdp),
            "neato" => Ok(Layout::Neato),
            "nop" => Ok(Layout::Nop),
            "nop1" => Ok(Layout::Nop1),
            "nop2" => Ok(Layout::Nop2),
            "osage" => Ok(Layout::Osage),
            "patchwork" => Ok(Layout::Patchwork),
            "sfdp" => Ok(Layout::Sfdp),
            "twopi" => Ok(Layout::Twopi),
            other => Err(format!("Unknown layout variant '{}'", other)),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(
    feature = "serde",
    derive(serde_derive::Serialize, serde_derive::Deserialize)
)]
pub enum OutputFormat {
    Canon,
    Cmap,
    Cmapx,
    CmapxNp,
    Dot,
    DotJson,
    Eps,
    Fig,
    Gd,
    Gd2,
    Gif,
    Gv,
    Imap,
    ImapNp,
    Ismap,
    Jpe,
    Jpeg,
    Jpg,
    Json,
    Json0,
    Kitty,
    Kittyz,
    Pdf,
    Pic,
    Plain,
    PlainExt,
    Png,
    Pov,
    Ps,
    Ps2,
    Svg,
    SvgInline,
    Svgz,
    Tk,
    Vrml,
    Vt,
    Vt24bit,
    Vt4up,
    Vt6up,
    Vt8up,
    Wbmp,
    Xdot,
    Xdot12,
    Xdot14,
    XdotJson,
}

impl fmt::Display for OutputFormat {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            OutputFormat::Canon => "canon",
            OutputFormat::Cmap => "cmap",
            OutputFormat::Cmapx => "cmapx",
            OutputFormat::CmapxNp => "cmapx_np",
            OutputFormat::Dot => "dot",
            OutputFormat::DotJson => "dot_json",
            OutputFormat::Eps => "eps",
            OutputFormat::Fig => "fig",
            OutputFormat::Gd => "gd",
            OutputFormat::Gd2 => "gd2",
            OutputFormat::Gif => "gif",
            OutputFormat::Gv => "gv",
            OutputFormat::Imap => "imap",
            OutputFormat::ImapNp => "imap_np",
            OutputFormat::Ismap => "ismap",
            OutputFormat::Jpe => "jpe",
            OutputFormat::Jpeg => "jpeg",
            OutputFormat::Jpg => "jpg",
            OutputFormat::Json => "json",
            OutputFormat::Json0 => "json0",
            OutputFormat::Kitty => "kitty",
            OutputFormat::Kittyz => "kittyz",
            OutputFormat::Pdf => "pdf",
            OutputFormat::Pic => "pic",
            OutputFormat::Plain => "plain",
            OutputFormat::PlainExt => "plain_ext",
            OutputFormat::Png => "png",
            OutputFormat::Pov => "pov",
            OutputFormat::Ps => "ps",
            OutputFormat::Ps2 => "ps2",
            OutputFormat::Svg => "svg",
            OutputFormat::SvgInline => "svg_inline",
            OutputFormat::Svgz => "svgz",
            OutputFormat::Tk => "tk",
            OutputFormat::Vrml => "vrml",
            OutputFormat::Vt => "vt",
            OutputFormat::Vt24bit => "vt-24bit",
            OutputFormat::Vt4up => "vt-4up",
            OutputFormat::Vt6up => "vt-6up",
            OutputFormat::Vt8up => "vt-8up",
            OutputFormat::Wbmp => "wbmp",
            OutputFormat::Xdot => "xdot",
            OutputFormat::Xdot12 => "xdot1.2",
            OutputFormat::Xdot14 => "xdot1.4",
            OutputFormat::XdotJson => "xdot_json",
        };
        write!(f, "{}", s)
    }
}

impl FromStr for OutputFormat {
    type Err = String;

    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input.to_ascii_lowercase().as_str() {
            "canon" => Ok(OutputFormat::Canon),
            "cmap" => Ok(OutputFormat::Cmap),
            "cmapx" => Ok(OutputFormat::Cmapx),
            "cmapx_np" | "cmapxnp" => Ok(OutputFormat::CmapxNp),
            "dot" => Ok(OutputFormat::Dot),
            "dot_json" | "dotjson" => Ok(OutputFormat::DotJson),
            "eps" => Ok(OutputFormat::Eps),
            "fig" => Ok(OutputFormat::Fig),
            "gd" => Ok(OutputFormat::Gd),
            "gd2" => Ok(OutputFormat::Gd2),
            "gif" => Ok(OutputFormat::Gif),
            "gv" => Ok(OutputFormat::Gv),
            "imap" => Ok(OutputFormat::Imap),
            "imap_np" | "imapnp" => Ok(OutputFormat::ImapNp),
            "ismap" => Ok(OutputFormat::Ismap),
            "jpe" => Ok(OutputFormat::Jpe),
            "jpeg" => Ok(OutputFormat::Jpeg),
            "jpg" => Ok(OutputFormat::Jpg),
            "json" => Ok(OutputFormat::Json),
            "json0" => Ok(OutputFormat::Json0),
            "kitty" => Ok(OutputFormat::Kitty),
            "kittyz" => Ok(OutputFormat::Kittyz),
            "pdf" => Ok(OutputFormat::Pdf),
            "pic" => Ok(OutputFormat::Pic),
            "plain" => Ok(OutputFormat::Plain),
            "plain_ext" | "plainext" => Ok(OutputFormat::PlainExt),
            "png" => Ok(OutputFormat::Png),
            "pov" => Ok(OutputFormat::Pov),
            "ps" => Ok(OutputFormat::Ps),
            "ps2" => Ok(OutputFormat::Ps2),
            "svg" => Ok(OutputFormat::Svg),
            "svg_inline" | "svginline" => Ok(OutputFormat::SvgInline),
            "svgz" => Ok(OutputFormat::Svgz),
            "tk" => Ok(OutputFormat::Tk),
            "vrml" => Ok(OutputFormat::Vrml),
            "vt" => Ok(OutputFormat::Vt),
            "vt-24bit" | "vt24bit" => Ok(OutputFormat::Vt24bit),
            "vt-4up" | "vt4up" => Ok(OutputFormat::Vt4up),
            "vt-6up" | "vt6up" => Ok(OutputFormat::Vt6up),
            "vt-8up" | "vt8up" => Ok(OutputFormat::Vt8up),
            "wbmp" => Ok(OutputFormat::Wbmp),
            "xdot" => Ok(OutputFormat::Xdot),
            "xdot1.2" | "xdot12" => Ok(OutputFormat::Xdot12),
            "xdot1.4" | "xdot14" => Ok(OutputFormat::Xdot14),
            "xdot_json" | "xdotjson" => Ok(OutputFormat::XdotJson),
            other => Err(format!("Unknown output format variant '{}'", other)),
        }
    }
}

#[derive(Debug, Clone)]
pub enum GraphErr {}

impl fmt::Display for GraphErr {
    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {} // exhaustive match â€” unreachable since no variants
    }
}

impl Error for GraphErr {}

impl From<GraphErr> for String {
    fn from(_: GraphErr) -> String {
        "GraphErr (unreachable, empty enum)".to_string()
    }
}

pub trait CompatGraph {
    type Cluster: CompatCluster;
    type Edge: CompatEdge;
    type Node: CompatNode;

    fn new<S: AsRef<str>, A: Attribute + Into<GraphAttr>>(name: S, attributes: Vec<A>) -> Self;

    /// Default node constructor using `CompatNode`
    fn new_node<L: AsRef<str>, S: AsRef<str>, A: Into<NodeAttribute>>(
        &mut self,
        label: L,
        id: S,
        attributes: Vec<A>,
    ) -> Result<String, GraphErr> {
        let id_ref = id.as_ref().to_string();
        let mut node = Self::Node::new(id_ref.clone(), label.as_ref().to_string());
        for attr in attributes {
            node.set_attr(attr);
        }
        self.add_node(node);
        Ok(id_ref)
    }

    /// Default edge constructor using `CompatEdge`
    fn new_edge<I: AsRef<str> + Clone, L: AsRef<str>, S: AsRef<str>, D: AsRef<str>>(
        &mut self,
        id: I,
        source: S,
        dest: D
    ) -> Result<I, GraphErr> {
        debug_assert_ne!(source.as_ref(), dest.as_ref());
        let edge = Self::Edge::new(id.clone(), source.as_ref().to_string(), dest.as_ref().to_string());
        self.add_edge(edge);
        Ok(id)
    }

    fn set_attr<A: Into<GraphAttr> + Attribute>(&mut self, attr: A);
    fn add_edge<E: Into<Self::Edge>>(&mut self, edge: E);
    fn add_node<N: Into<Self::Node>>(&mut self, node: N);
}

pub trait GraphExt: CompatGraph {
    type NodeIter<'a>: Iterator<Item = &'a Self::Node>
    where
        Self: 'a;

    type NodeIterMut<'a>: Iterator<Item = &'a mut Self::Node>
    where
        Self: 'a;

    fn node_iter(&self) -> Self::NodeIter<'_>;
    fn node_iter_mut(&mut self) -> Self::NodeIterMut<'_>;
    /// Default: apply closure to all nodes of a given class
    fn apply_to_class<F>(&mut self, classname: &str, mut f: F)
    where
        F: FnMut(&mut Self::Node),
    {
        for node in self.node_iter_mut() {
            if node.has_attr(CommonAttr::Class(classname.to_string())) {
                f(node);
            }
        }
    }

    /// Default: collect all nodes of a given class into a Vec
    fn nodes_by_class<'a>(
        &'a mut self,
        classname: &str,
    ) -> Vec<&'a mut Self::Node> {
        self.node_iter_mut()
            .filter(|n| n.has_attr(CommonAttr::Class(classname.to_string())))
            .collect()
    }
}

pub trait CompatNode {
    fn new<S: AsRef<str>>(id: S, label: S) -> Self;
    fn set_attr<A: Into<NodeAttribute>>(&mut self, attr: A);
    fn has_attr<A: Into<NodeAttribute>>(&self, attr: A) -> bool;
}

pub trait CompatEdge {
    fn new<S: AsRef<str>, I: AsRef<str>, D: AsRef<str>>(id: I, source: S, dest: D) -> Self;
    fn set_attr<A: Into<EdgeAttribute>>(&mut self, attr: A);
}

pub trait CompatCluster {
    fn new<S: AsRef<str>>(name: S) -> Self;
    fn set_attr<A: Into<NodeAttribute>>(&mut self, attr: A);
}